<!-- Model Link: https://teachablemachine.withgoogle.com/models/VbfQgzD3J/ -->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Rock Paper Scissors</title>
    <link rel="stylesheet" href="./styles/css/main.css">
</head>

<body>

    <!-- Template Code -->

    <div id="windowWrapper">
        <div id="containerWindow">
            <div id="chromeBar">
                <div class="circle"></div>
                <div class="circle"></div>
                <div class="circle"></div>
                <p>ML Rock Paper Scissors</p>
            </div>
            <div id="webcam-container" class="halfContainer"></div>
            <div id="computer-container" class="halfContainer">🤖</div>
            <h1 id="vs">▶</h1>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8/dist/teachablemachine-image.min.js"></script>
    <script type="text/javascript">
        // More API functions here:
        // https://github.com/googlecreativelab/teachablemachine-community/tree/master/libraries/image

        // the link to your model provided by Teachable Machine export panel
        const URL = "https://teachablemachine.withgoogle.com/models/VbfQgzD3J/";

        let model, webcam, labelContainer, maxPredictions, timer;

        window.onload = () => {
            init();
        }

        // Load the image model and setup the webcam
        async function init() {
            const modelURL = URL + "model.json";
            const metadataURL = URL + "metadata.json";

            // load the model and metadata
            // Refer to tmImage.loadFromFiles() in the API to support files from a file picker
            // or files from your local hard drive
            // Note: the pose library adds "tmImage" object to your window (window.tmImage)
            model = await tmImage.load(modelURL, metadataURL);
            maxPredictions = model.getTotalClasses();

            // Convenience function to setup a webcam
            const flip = true; // whether to flip the webcam
            webcam = new tmImage.Webcam(300, 300, flip); // width, height, flip
            await webcam.setup(); // request access to the webcam
            await webcam.play();
            window.requestAnimationFrame(loop);

            // append elements to the DOM
            document.getElementById("webcam-container").appendChild(webcam.canvas);
        }

        async function loop() {
            webcam.update(); // update the webcam frame
            window.requestAnimationFrame(loop);
        }

        async function displayResults() {
            var time = 3;
            var displayOptions = ['🏁', '✌', '✋', '✊'];
            if (!timer) {
                timer = setInterval(async () => {
                    if (time > -1) {
                        document.querySelector("#vs").innerHTML = displayOptions[time];
                        time--;
                    } else {
                        clearInterval(timer);
                        document.querySelector("#vs").innerHTML = '▶';
                        var res = await startGame();
                        let compChoice = document.querySelector("#computer-container");

                    }
                }, 1000)
            }
        }

        function toEmoji(name) {
            switch (name) {
                case 'Paper':
                    return '✋';
                    break;
                case 'Scissors':
                    return '✌';
                    break;
                case 'Rock':
                    return '✊';
                    break;
                    
                default:
                    break;
            }
        }

        // run the webcam image through the image model
        async function startGame() {
            let probability = 0, playerGuess;
            // get a random guess for the computer
            let classNames = ["Rock", "Paper", "Scissors"];
            let computerGuess = classNames[Math.floor(Math.random() * classNames.length)];
            // predict can take in an image, video or canvas html element
            // get the guess from the player's webcam
            const prediction = await model.predict(webcam.canvas);
            // find the className with the highest probability
            for (let i = 0; i < maxPredictions; i++) {
                if (probability < prediction[i].probability.toFixed(2)) {
                    playerGuess = prediction[i].className;
                    probability = prediction[i].probability.toFixed(2);
                }
                console.log(prediction[i].className, prediction[i].probability.toFixed(2))
            }
            return [checkWinner(computerGuess, playerGuess), computerGuess, playerGuess];
        }

        function checkWinner(computer, player) {
            // check for a tie
            if (player === computer) return 'tie';
            // check for a computer win
            // NOTE: this could be condensed into a singular if statement, 
            // but I find it easier to follow this way
            if (player === 'Paper' && computer === 'Scissors') return 'computer';
            if (player === 'Rock' && computer === 'Paper') return 'computer';
            if (player === 'Scissors' && computer === 'Rock') return 'computer';
            // player wins if none of the above were true
            return 'player';
        }
    </script>
</body>

</html>